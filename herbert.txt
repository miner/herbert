Herbert -- a schema notation for EDN

These are just notes to myself.  Probably not useful to anyone else.

Actually, lots of things are wrong in this document, or haven't kept up with the code.

----------------------------------------------------------------------

Movitvations:  want simple language for describing data and function requirements.  Better, more
precise doc.  Also, it can be used for transformations (like XSLT) and validation.

I like to say that Herbert notation is "whiteboard-compatible".

Nice to have bindings like a parser.  But mostly want validation for "shape of data".

But a parser can also give you the parse tree with named bindings which might be useful.  Or maybe
just bindings is good enough since Clojure has lots of ways for transforming the data.

We should restrict ourselves to EDN types.  No records, but you can use the convention that
#my.ns/Rec {:a x :b y} refers to a record my.ns.Rec.  No Java types, but you could maybe use tags
for that as well.  Although, it may be too tricky to impose a convention for language-specific
types.

But really, we won't get any literal tagged values because we have to read that data first.  Use a
default-tagged-value-reader fn to convert all tagged values to a TaggedValue record.  (Also,
override #uuid and #inst -- really should do everything in default-data-readers.)

----------------------------------------------------------------------
** Ideas **

Typed Racket has lots of ideas
http://docs.racket-lang.org/ts-guide/types.html

Clojure -- Core.Typed is similar to Typed Racket
https://github.com/clojure/core.typed

Haskell Type notation might be useful or at least a common translation format
http://www.infoq.com/presentations/Type-Functional-Design

Relax/NG
 http://www.relaxng.org/compact-tutorial-20030326.html
 http://infohost.nmt.edu/tcc/help/pubs/rnc/

EDN   https://github.com/edn-format/edn

Look at clj-schema lib:
https://github.com/runa-dev/clj-schema

Nice, new parser lib:
https://github.com/Engelberg/instaparse

Another parser:
https://github.com/mthvedt/clearley

Yet another parser, says it also works with seqs, not just chars
https://github.com/ericnormand/squarepeg

Nippy serialization -- maybe related
https://github.com/ptaoussanis/nippy

----------------------------------------------------------------------

===> SquarePeg looks very promising as a basis for Herbert.  Let's start there.

issue: squarepeg bindings use keywords.  I was planning to use normal Clojure destructuring.  Maybe
use a macro to compile into a let with destructuring?  Actually, square peg can bind to symbols but
the predicates are awkward to write because the only get a one-arg, a map of bindings, so you have
to (get % 'x).  Nicer to read (:x %).

Binding with :kw works OK and fits in with prismatic/plumbing fnk.  

It would be interesting to compare an implementation using core.logic to the squarepeg version.
[org.clojure/core.logic "0.8.3"]

----------------------------------------------------------------------


Shape of data

Maybe like UML data modeling but simpler and less work.

Idea from Stuart Sierra's strange loop "Functional Design Patterns" talk:  define protocol for
Acceptors.  Then have the data type decide which acceptor to call.  Or maybe have the schema type
decide.  Not sure.

Sierra gave an older talk about the shape of data:

http://www.infoq.com/presentations/Thinking-in-Data


Haskell Pattern Matching

http://www.haskell.org/tutorial/patterns.html

interesting question about lazy patterns, infinite streams and recursive structures


Martin Fowler on schemaless data structures
  conclusion: schemaless => implicit schema (bad), so prefer explicit schemas
http://martinfowler.com/articles/schemaless/

SEM says: OK so we want a simple notation for an informal schema (required keys for a map, etc.)

----------------------------------------------------------------------


Decision: [int*] means seq of ints, not inlined.  You can use (& int sym) for
inlining.   Inlining is also done with "splice" ops (* + ? N)

----------------------------------------------------------------------


* Binding
we want an easy way to bind matches
(name type)

name must be distinct from types and ops

* No sub-Guards on types  
Make it easy to write a predicate for your exact type.
Allow params to "predicates" (with object x as last arg) for extended options.

For example, I defined odd and even (and (integer? x) (odd? x))


* Clojure destructuring -- NOT DONE, conflicts with other ideas
try to reuse as much as possible
but maybe conflicts with some other notations

* inline sequence -- using (& int sym) notation

* Cross-constraints with bindings

([(:name str) (:name2 str) (guard (== (count (:name %) (count (:name2 %)))))])

* NO on grammar approach.  We're using fns and combinators so just define them with vars.
Maybe later, we could take a map grammar and do the right thing.


* literals
nil, true, false
:keywords
:ns/kw
'symbols
'ns/symbols
"literal string"
\C

* wildcard
any -- matches any type
NOT IMPL -- (underscore) _  match anything and ignore it (multiple _s match independently)

* types (reserved)
bool
str
char
sym
kw
int
float
list
vec
map
set
tag

* synonyms, aliases, NOT IMPL
long == int
double == float
integer == int
etc.

* abstract or specialized types (reserved) -- many NOT IMPL yet
element or any -- anything
seq   -- same as (or list vec)
num  -- (or int float)
qsym -- qualified symbol
usym -- unqualified symbol
qkw
ukw
qtag
utag


* regex? -- but not EDN type, but maybe should use a tagged literal
#herbert/regex "regex"
(regex "regex") -- instead?


* parameterized simple types
(str N) -- length
(str "pat") -- matches glob or regex?
(int N M) -- between <= (inclusive?)
(sym "ns" "name") -- matches ns and name (regex?)
(sym "name")  -- unqualified
(kw "ns" "name")
(kw "name")  -- unqualified

(quote foo)
'foo -- matches exactly symbol foo, turns a symbol into a literal


* operators
(or t1 t2)  -- one element that satisfies either type
(and t1 t2) -- one element that satisfies both types
(not t) -- one element that is not t

(quote X) -- literal, no special interpretation (same as 'X)
(ns MY.NS) -- symbol or kw with given namespace
(name NAME) -- symbol, kw or string with given name

* cycles and splices -- notice inline (no explicit collection)
(* t) zero or more
(+ t) one or more
(? t) zero or one
(N t) exactly N
([M N] t)  between M and N (inclusive)
(* t1 t2 t3) -- matches empty, t1 t2 t3 t1 t2 t3 ...
(+ t1 t2 t3) -- matches (non-empty) t1 t2 t3 t1 t2 t3 ...
(? t1 t2 t3) -- matches empty or exactly t1 t2 t3

(N t1 t2 t3) -- exactly N total elements, cycling through types

I think we should drop the N and [M N] ops, not really needed

was =, but changed to & for inline ordered elements
(& t1 t2 t3) -- exactly 1 inlined seq of elements, same as (N t1 t2 ... tN) where N=count(ts)

Note:  maybe should remove the Numbered quantifier -- not sure if it's worth the complexity?
Especially with the multiple items: is the count total elements or cycles?

If N is * then any length is allowed. Also, + and ?, and [N M]. 
[N] means N or more  (sort of like [N *] but that's not used

* compact quantifiers for simple names
t* === (* t)
t? === (? t)
t+ === (+ t)

Note: options apply to single type
(int* 10) is same as (* (int 10))

* sequences

(vec t1 t2 ... tN)  -- vector of elements in exact order
(list t1 t2 ... tN)  -- list of elements in exact order
(seq t1 t2 ... tN)  -- seq of elements in exact order
(set t1 t2 ... tN) -- set with all elements, unordered

(vec (N t)) -- vector of N elements all t
(vec (3 t1 t2)) -- vector of 6 elements: t1 t2 t1 t2 t1 t2
(vec (* t)) -- vector of any number of t

square brackets match any seq
[t1 t2 t3]  -- any seq (vec or list) containing exactly (t1 t2 t3)
#{t1 t2 t3} -- matches a set with the required elements, others optional

* map
(map kw t .. kwN tN)  -- kw must be present, val must be t
{:a int :b float :c str}  -- literal keys (required) and type exprs
(keys :a :b :c) -- required keys, but others allowed, except for (not :x)

Question: optional keys?  going with first form -- :a?
{:a? int :b? str}
{:a int? :b str?}

disallowed key -- literally it's optional and must be nil, but effectively disallowed
{:a? nil}


with second form since :a is required, it's not very useful to int? (as opposed to int)


* REJECTED IDEAS
no inline map {t1 t2 .. tN tN+1}  -- all elements in pairwise order  -- NOT SURE

* inline -- NO, use cycle and splices instead
[t1 t2 ... tN] -- in that order (not nested in vector)
#{t1 t2 ... tN} -- a set with all elements required in no particular order, see also OR



----------------------------------------------------------------------
* Issues

Kind of not liking the (N t t2) operator, probably better just to spell it out for N times
similarly ([L H] t t2 ...) looks noisy
	  something like this should work (= t t t t? t?)

remember that a number is a literal to match in most postions so it looks funny as an op

If you need a huge number, try an explicit (repeat N t)

----------------------------------------------------------------------
maybe :start special key for start of schema
or else just require user to give start symbol, allowing multiple entry points

{foo [int str baz]
 baz (keys :a :b)
 :start foo}

;; rarely needed
(keys (not :a)) ==> (and map (not (keys :a)))
-- map without :a as a key

(not (keys :a))  -- not necessarily a map at all

or use {:a? nil} for effectively disallowing the :a key

----------------------------------------------------------------------
implementation approach

convert schema map to canonical form and then to a logic program

----------------------------------------------------------------------
examples

(int x :when (< x 10))
(string :when (< (count string) 25))  -- reuse type name as binding?
(string :as s :when (< (count s) 25))  -- reuse type name as binding?
(string :when (< (count %) 25))  -- % as single arg

(int x even?)
(int x :pred even?)
(int x :pred #'even?) -- not EDN
(int x :when even?)
(int x (even? x))
(int x #(even? x))   -- not EDN
(int x :when (even? x))

(int x (<= 5 x 10))
(int x :when (<= 5 x 10))
(int :when (<= 5 % 10))
(int x 5 10)  -- default op is <=

(str x "foo.bar")
(str x :when (re-matches #"foo.bar"))

(map m :a int :b int :c str :when (< (:a m) (:b m)))

(map {:keys [a b c] :as m} :when (< a b))

(keys :a :b :c)  ===> (map {:keys [a b c] :or {a ::missing b ::missing c ::missing}} 
      	    	      	   :when (and (not= a ::missing) (not= b ::missing) (not= c ::missing)))


----------------------------------------------------------------------
Why Relax/NG is better than XML-Schemas
http://www.infoq.com/news/2007/10/relaxng
----------------------------------------------------------------------


Relax/NG Compact form in Clojure prefix notation

grammar is a map of {element pattern}
'start' is the reserved name for the starting (root) element of the grammar
elements are just symbols, by convention capitalized
patterns are usually list expressions, but can be predefined symbols

{start AddressBook
 AddressBook (vec (* Card))
 Card (map :name Name :email Email)
 Name (str #"\w")
 Email (str #".*@.*")}

Question:  prefix or postfix * ?
 AddressBook (vec (* Card))
 AddressBook (vec Card*))
 AddressBook [Card*]

for limited numbers:
 AddressBook (vec Card+)
 AddressBook (vec Card?)
 AddressBook (vec (3 Card))
 AddressBook (vec [2 3] Card)
 AddressBook (or (vec 2 Card) (vec 3 Card))

[{:name "Steve" :email "sm@gm.com"} {:name "Lisa" :email "lisa@lm.com"}]


;; vector with an even number of ints
(vec (* int int))

Interleaving (probably not needed as defined in RNC)

RNC external is for including another *.rnc file.  By analogy, we might want to include another
grammar map.  Maybe use @notation?  (or #')?

(def grammar1 '{start AddressBook AddressBook (vec Card) ...})

(def grammar2 '{start {:first str :last str :abk AddrBk}  AddrBk @grammar1})


Extra bonus feature
Nesting names, should follow lexical scope.  (parent Name) allows outer reference if needed

what about a rewrite rule to avoid name clashes? (rename @grammar1 {foo bar baz quux}) or whatever
ns require does?

or just use namespaces properly and there's no conflict?
----------------------------------------------------------------------

Totally wild and mostly separate idea for tagged args: evaluate normally to the arg symbol (so the
compiler doesn't see anything different, but can add assertions when flags set.

(defnx foo [(int x (<= 3 x 10)) (str y)]
  (apply str (repeat x y)))

(defn foo [(int x) (str y)]
  {:pre [(<= 3 x 10)]}
  (apply str (repeat x y)))

(defcon int3t (contype int (<= 3 % 10)))

(defn foo [(int3t x) (str y)]
  (apply str (repeat x y)))

(defn foo [x y]
  {:pre [(and (integer? x) (<= 3 x 10)) (string? y)]}
  (apply str (repeat x y)))



----------------------------------------------------------------------
type expressions
symbol -- just the base type named by symbol
(symbol name) -- symbol is base type, name is bound to value
(symbol name constraint) -- constraint is an expression treated as the body of a single arg pred

if name = :when that's the same as _ (meaning don't care, no binding)


"Clojure in the Wild Webâ€“7 Reflections"
http://www.infoq.com/presentations/Clojure-ReadyforZero
around 11:00
common bug: non-existent key
----------------------------------------------------------------------

Why I use eval to create the runtime functions

;; example from http://tojava3.appspot.com/question/5080fdf94f1eba38a4dd174e
#_ (defmacro make-primitive-affine-function [t a b]
  (let [cast #(list (symbol (name t)) %)
        x (gensym "x")]
    `(fn [~x] (+ (* ~(cast a) ~(cast x)) ~(cast b)))))

#_ ((make-primitive-affine-function :int 31 47) 5)
; => 202

;; need to use eval
;; http://stackoverflow.com/questions/1824932/clojure-how-to-create-a-function-at-runtime

;; FIXME -- this is dangerous is you allow user-defined guards.  They could (launch-missiles)!
;; We should define allowed functions and audit the guard code.
(defn runtime-fn [arg expr]
  (eval `(fn [~arg] ~expr)))

----------------------------------------------------------------------
so what about #{set} notation for any order but all required?
actually, handle it like a map but just keys
must be a set
set as whole must satisfy all of the contained expressions

makes sense with literals
more complicated with types

#{int*}  -- any number of ints
#{int sym} -- one int and one sym, or at least one?
#{:a :b :c} -- exact literals
#{int* sym?} -- any number of ints, zero or one sym -- but really not constrained

means that other things are also allowed unless you say (and (not #{:c}) #{:a :b})

compile #{(not foo) x y}  ---> (and #{x y} (not #{foo}))

also has implications for maps when you handle other key types
you could say that just literal keys are allowed for literal {} and #{}

sort constraints:
literals -- exact match, one rule per lit or combine into a set and check intersection
singles -- one rule per single, test every element so that it matches at least one rule
	one element could actually match more than one rule
multiples  -- one multiple means every element matches the single version of the rule

A set may contain other things so we don't want to say every element must match some rule.
Every rule must match some element? Even the same one?

Really, int* doesn't constrain much since zero is easy.  int+ isn't much different from int.  So
let's say * and ? items dropped completely and + is just the same as base.

Allow one multiple int* to mean only ints.  int+ one or more but only ints

#{int*} -- a set of ints and nothing but ints
#{int+} -- a set of one or more ints, nothing else
#{int?} -- a set of one int or empty


;; a mixed set of ints or syms
#{(* (or int sym))}  -- or something like #{isym*}

literals are required, but others OK
#{:a "foo" 10}  -- required elements 


use same interpretation for a map (keys c c2...)

----------------------------------------------------------------------

Issue: what about (* int*)  -- should be same as int*
quantifier ops should simple-sym their underlying types
(* (or int* sym*))  -- same as (* (or int sym))

probably should be an error to mix qsyms with qop

----------------------------------------------------------------------
Maybe should predefine all int*, etc. rather than runtime computation.  But "runtime" isn't
necessarily bad since you can "compile" the constraint fns with (conforms? con)

Guards on quantified types?
  apply per element?  -- no
  apply to whole matching collection? -- seems fair

:step two-arg function applies to previous and current
:step inc
first element is initial value, untested

(ints* :when <) -- 3 4 5
(inst* :step inc)

but that's inconsistent with explicit naming of args

(ints* ns :when (apply < ns)) -- 3 4 5

(ints* [n & more :as ns] :step (inc n))

(* int int int)
----------------------------------------------------------------------

Datomic -- we should be able to create datomic schemas from Herbert constraints.

http://blog.markwatson.com/2012/07/a-little-clojure-wrapper-for-datomic/
----------------------------------------------------------------------

Major revision.  No binding names, maybe just :kw.
No "code expressions" for guards, just var names.  Maybe also anonymous fn, but that's not
edn-compatible, and it would be nice if the schema was all edn.


(int even?)
(int pos? odd?)

(int :a) (int :b) (int :c)
((& int int int) >)


;; tests if coll matches the result of (take (count coll) (iter f (first coll)))

(defn iter1? [f coll]
  (reduce (fn [cur x] (if (= x (f cur)) x (reduced false)))
            (first coll)
	    (rest coll)))

(defn iter? [f coll]
     (= coll (take (count coll) (iterate f (first coll)))))

(int* :iter inc)
(int* >)

(int* :step 3)   matches [4 7 10]

(int :in [0 10])
(int :in #{7 11})
(int :in 10)
(str :in "regex")
(str :in ["a" "m"])   -- any first letter between "a...m"
(str :in ["AAA" "zzz"])   -- any first three letter between "AAA...zzz"  (< upper lower)

(sym :in #{foo bar baz})


New syntax for (list expr)
first item is the type descriptor
second+ symbols name predicates (even? odd? etc)
at end of list can be kw + single args

(defn dplus [x] (* 2 (inc x)))


(int :in val)  -- inclusive between (implemented as protocol)
(vec :as v)  -- bind match to symbol
(int* :step 3)  -- matching ints should be +3 apart (like range assuming first int is start)
(int* :iter dplus) -- matches if iterate over fn would produce the elements, first is start

(type pred1 :in literal :as bind)
(int* pred :step 3)

(int* :iter dplus)

(int* :iter dec)  ===> (10 9 8 7)
(int* :step -1)  ===> (10 9 8 7)

(int :is (+ 3 n))
(int :is (plus3 n))  -- not predicate but function result, tested with =, n from previous binding

:is vs. :as -- easy typo
:=

(int :is (+ 3 n))
(int := (+ 3 n))
(int = (+ 3 n))
(int :in #{(+ 3 n)})

maybe cross item constraint should be a separate expression

(int odd? :as n) (int even? :as m) (assert (> n m))

----------------------------------------------------------------------

Don't use = for splice, maybe splice or repeat
Decided that & looks OK for now
----------------------------------------------------------------------

Bug with quants
(int* :step 3)  was looking like (* (int :step 3))
should be ((* int) :step 3)

but even with the second one the step function is getting called with an empty input

(int* even?)  could be (* (int even?))
vs. (int* :every even?)

(def even (tconstraint '(int even?)))

(even* 

Issue: should guards bind to the simple type or apply to the whole collection?

Clearly kw args, like :step, :iter, :as should apply to whole collection
:in is a toss up.

Simple rule is that guards apply to whole collection.

But the more practical idea is to bind guards to the base type and the kw args to the collection.

(def pair (tconstraint '(& kw int)))

(pair*   UNFINISHED
----------------------------------------------------------------------

ISSUE: how to define new basic types?  You can define a fn but how is it added to the list?  Right
now, we look up the symbol and return a predicate.  That could be in a dynamic var or atom that's
updated.

ISSUE: how can you tell a single item term from a multi-item or collection term?  Collection is like
a single item, but also has internal structure like multiple items.

IDEA:  alternate way to do binding instead of :as.  Use leading :kw which works well with square peg
convention.  Maybe not so good for normal fn args but I think that's OK.

[(:n int even?) (:s sym)]

[(n int even?) (s sym)]

[(int even? :as n) (sym :as s)]

if binding name is distinct from simple types we can figure it out in first position of list

(ns int* even?)
----------------------------------------------------------------------


Change guard syntax to be more like a fn declaration.  You must name the args, which must match some
previously declared binding names.

Old:
 [(n int) (m int) (guard (= (* 2 (get % 'n)) (get % 'm))) ]

New:
 [(n int) (m int) (guard [n m] (= (* 2 n) m))]


Guards are similar to prismatic "fnk" functions.  (Pronounced "fun-kay" by me as interpreted by Wild
Cherry "Play That Funky Music") A fnk function takes one-arg, a map of bindings but it's declared
with multiple args (which are interpreted like {:keys ...} destructuring).

For Herbert guards, I like using symbols for binding names (not keywords).  We could automatically
handle that if we really need to use fnk syntax but I don't see the need at the momment.

Also Square Peg doc uses keyword keys for binding but it works as well with symbols.

New idea (on top of the new guard syntax): In theory, you could scan the body and find the free
symbol references so it's kind of redundant to require the vector of 'args'.  (It does make the
implementation easier.  Also it maybe provides a visual marker and a bit of a double-check on the
body, but that's an accident of the implementation rather than a design decision.)

----------------------------------------------------------------------

Unimplemented idea:
Use (name) with no type as a constraint to be exactly the same as a previous binding for name.

[(a int) (a) (a)]  matches [3 3 3], [4 4 4], etc.

----------------------------------------------------------------------
Need to consider nested binding names in quantifiers.  Only makes sense to bind at top level if
there may be multiple matches.  Currently, last one probably wins.

----------------------------------------------------------------------
